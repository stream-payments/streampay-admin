"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDepGraphNpmLockV2 = exports.parseNpmLockV2Project = exports.extractPkgsFromNpmLockV2 = void 0;
const extract_npm_lock_v2_pkgs_1 = require("./extract-npm-lock-v2-pkgs");
Object.defineProperty(exports, "extractPkgsFromNpmLockV2", { enumerable: true, get: function () { return extract_npm_lock_v2_pkgs_1.extractPkgsFromNpmLockV2; } });
const dep_graph_1 = require("@snyk/dep-graph");
const util_1 = require("../util");
const errors_1 = require("../../errors");
const parsers_1 = require("../../parsers");
const parseNpmLockV2Project = (pkgJsonContent, pkgLockContent, options) => {
    const { includeDevDeps, strictOutOfSync, includeOptionalDeps } = options;
    const pkgJson = (0, util_1.parsePkgJson)(pkgJsonContent);
    const pkgs = (0, extract_npm_lock_v2_pkgs_1.extractPkgsFromNpmLockV2)(pkgLockContent);
    const depgraph = (0, exports.buildDepGraphNpmLockV2)(pkgs, pkgJson, {
        includeDevDeps,
        includeOptionalDeps,
        strictOutOfSync,
    });
    return depgraph;
};
exports.parseNpmLockV2Project = parseNpmLockV2Project;
const buildDepGraphNpmLockV2 = (npmLockPkgs, pkgJson, options) => {
    const { includeDevDeps, strictOutOfSync, includeOptionalDeps } = options;
    const depGraphBuilder = new dep_graph_1.DepGraphBuilder({ name: 'npm' }, { name: pkgJson.name, version: pkgJson.version });
    const topLevelDeps = (0, util_1.getTopLevelDeps)(pkgJson, {
        includeDevDeps,
        includeOptionalDeps,
        includePeerDeps: true,
    });
    const rootNode = {
        id: 'root-node',
        name: pkgJson.name,
        version: pkgJson.version,
        dependencies: topLevelDeps,
        isDev: false,
        inBundle: false,
    };
    const visitedMap = new Set();
    dfsVisit(depGraphBuilder, rootNode, visitedMap, npmLockPkgs, strictOutOfSync, includeOptionalDeps, []);
    return depGraphBuilder.build();
};
exports.buildDepGraphNpmLockV2 = buildDepGraphNpmLockV2;
const dfsVisit = (depGraphBuilder, node, visitedMap, npmLockPkgs, strictOutOfSync, includeOptionalDeps, ancestry) => {
    visitedMap.add(node.id);
    for (const [name, depInfo] of Object.entries(node.dependencies || {})) {
        // console.log(node);
        const childNode = getChildNode(name, depInfo, npmLockPkgs, strictOutOfSync, includeOptionalDeps, [...ancestry, { name: node.name, inBundle: node.inBundle || false }]);
        if (!visitedMap.has(childNode.id)) {
            (0, util_1.addPkgNodeToGraph)(depGraphBuilder, childNode, {});
            dfsVisit(depGraphBuilder, childNode, visitedMap, npmLockPkgs, strictOutOfSync, includeOptionalDeps, [...ancestry, { name: node.name, inBundle: node.inBundle || false }]);
        }
        depGraphBuilder.connectDep(node.id, childNode.id);
    }
};
const getChildNode = (name, depInfo, pkgs, strictOutOfSync, includeOptionalDeps, ancestry) => {
    const childNodeKey = getChildNodeKey(name, ancestry, pkgs); //
    if (!pkgs[childNodeKey]) {
        if (strictOutOfSync) {
            throw new errors_1.OutOfSyncError(`${name}@${depInfo.version}`, parsers_1.LockfileType.npm);
        }
        else {
            return {
                id: childNodeKey,
                name: name,
                version: depInfo.version,
                dependencies: {},
                isDev: depInfo.isDev,
                missingLockFileEntry: true,
            };
        }
    }
    else {
        const depData = pkgs[childNodeKey];
        const dependencies = (0, util_1.getGraphDependencies)(depData.dependencies || {}, depInfo.isDev);
        const optionalDependencies = includeOptionalDeps
            ? (0, util_1.getGraphDependencies)(depData.optionalDependencies || {}, depInfo.isDev)
            : {};
        return {
            id: `${name}@${depData.version}`,
            name: name,
            version: depData.version,
            dependencies: Object.assign(Object.assign({}, dependencies), optionalDependencies),
            isDev: depInfo.isDev,
            inBundle: depData.inBundle,
        };
    }
};
const getChildNodeKey = (name, ancestry, pkgs) => {
    const parent = ancestry[ancestry.length - 1];
    if (parent.inBundle) {
        const bundleRootIdx = ancestry.findIndex((el) => el.inBundle === true) - 1;
        const ancestryNamesOfInterest = ancestry
            .slice(bundleRootIdx)
            .map((ancestry) => ancestry.name)
            .concat([name]);
        const getPossibleDepPaths = (currPaths) => {
            if (currPaths.length === 1) {
                return currPaths;
            }
            const first = currPaths[0];
            const rest = currPaths.slice(1);
            const resPaths = getPossibleDepPaths(rest);
            return resPaths.map((el) => `${first}/${el}`).concat(resPaths);
        };
        for (let splitPoint = ancestryNamesOfInterest.length - 1; splitPoint > 0; splitPoint--) {
            const left = ancestryNamesOfInterest.slice(0, splitPoint);
            const right = ancestryNamesOfInterest.slice(splitPoint);
            if (right.length === 1) {
                const key = `node_modules/${left.join('/node_modules/')}/node_modules/${name}`;
                if (pkgs[key]) {
                    return key;
                }
            }
            else {
                for (let rightPointer = 1; rightPointer < right.length; rightPointer++) {
                    const options = getPossibleDepPaths(right.slice(rightPointer));
                    for (let optIdx = 0; optIdx < options.length; optIdx++) {
                        const rightConcat = `node_modules/${options[optIdx].replace(/\//g, '/node_modules/')}`;
                        const key = `node_modules/${left.join('/node_modules/')}/${rightConcat}`;
                        if (pkgs[key]) {
                            return key;
                        }
                    }
                }
            }
        }
    }
    // If not in bundle then we can just see if it is scoped by parent
    // and then just look directly for it
    if (ancestry.length === 1) {
        return `node_modules/${name}`;
    }
    const parentName = ancestry[ancestry.length - 1].name;
    return pkgs[`node_modules/${parentName}/node_modules/${name}`]
        ? `node_modules/${parentName}/node_modules/${name}`
        : `node_modules/${name}`;
};
//# sourceMappingURL=index.js.map